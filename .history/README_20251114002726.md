# SystÃ¨me de Notification FlashNotify

Application web Flask et FastAPI dÃ©montrant l'utilisation de concepts POO avancÃ©s en Python : **DÃ©corateurs de classes**, **Descripteurs** et **MÃ©taclasses** avec intÃ©gration d'un systÃ¨me d'authentification, de files d'attente asynchrones et d'une API moderne.

## ğŸ“‹ Vue d'ensemble

Ce projet est un systÃ¨me de notification complet qui permet d'envoyer des notifications par diffÃ©rents canaux (Email, SMS, Push) selon le type d'urgence et les prÃ©fÃ©rences utilisateur. L'application utilise Flask pour l'interface web, FastAPI pour l'API moderne, PostgreSQL pour la base de donnÃ©es, et dÃ©montre l'utilisation de concepts POO avancÃ©s pour amÃ©liorer la maintenabilitÃ© et l'extensibilitÃ© du code. Le systÃ¨me inclut Ã©galement une authentification sÃ©curisÃ©e, un systÃ¨me de files d'attente asynchrone et une documentation API complÃ¨te.

## ğŸ¯ Concepts POO AvancÃ©s ImplÃ©mentÃ©s

### 1. DÃ©corateurs de Classes

Les dÃ©corateurs de classes ajoutent des fonctionnalitÃ©s transversales sans modifier le code existant.

**Fichier : `core/decorators.py`**

#### `@add_performance_tracking`
- Ajoute automatiquement le suivi des performances Ã  chaque envoi de notification
- Enregistre la durÃ©e d'exÃ©cution de chaque mÃ©thode
- Calcule les moyennes de performance

#### `@auto_configuration_validation`
- Valide automatiquement la configuration au moment de l'instanciation
- VÃ©rifie que tous les champs requis sont prÃ©sents

#### `@register_in_global_registry`
- Enregistre automatiquement la classe dans un registre global
- Permet la dÃ©couverte automatique des notificateurs

#### `@add_circuit_breaker`
- ImplÃ©mente le pattern Circuit Breaker
- GÃ¨re automatiquement les pannes en ouvrant le circuit aprÃ¨s trop d'Ã©checs
- Se rÃ©initialise automatiquement aprÃ¨s un timeout

**Exemple d'utilisation :**
```python
@add_performance_tracking
@auto_configuration_validation
@register_in_global_registry
@add_circuit_breaker(max_failures=5, timeout=60)
class AcademicNotifier:
    # La classe bÃ©nÃ©ficie automatiquement de toutes ces fonctionnalitÃ©s
    pass
```

### 2. Descripteurs

Les descripteurs permettent de contrÃ´ler l'accÃ¨s aux attributs et de valider automatiquement les donnÃ©es.

**Fichier : `core/descriptors.py`**

#### `EmailDescriptor`
- Valide automatiquement le format email lors de l'affectation
- Utilise une regex pour vÃ©rifier la prÃ©sence de @ et d'un domaine valide
- LÃ¨ve une `ValueError` si l'email est invalide

#### `PhoneDescriptor`
- Valide les numÃ©ros de tÃ©lÃ©phone internationaux
- Format requis : +[code pays][numÃ©ro] (ex: +33612345678)
- Supporte entre 7 et 15 chiffres

#### `PriorityDescriptor`
- ContrÃ´le les niveaux de prioritÃ© (LOW, MEDIUM, HIGH, CRITICAL)
- Convertit automatiquement en majuscules
- Valeur par dÃ©faut : MEDIUM

#### `TimeWindowDescriptor` - Nouveau!
- Valide les plages horaires au format HH:MM
- MÃ©thode `is_in_window()` pour vÃ©rifier si l'heure est dans la plage dÃ©finie
- Support des plages chevauchant minuit

**Exemple d'utilisation :**
```python
class User:
    email = EmailDescriptor()
    phone = PhoneDescriptor()
    time_preference = TimeWindowDescriptor(start_hour=9, end_hour=17)
    
    def __init__(self, email, phone):
        self.email = email  # Validation automatique ici
        self.phone = phone  # Validation automatique ici
        self.time_preference = {'start': '09:00', 'end': '17:00'}  # Validation automatique
```

### 3. MÃ©taclasses

Les mÃ©taclasses gÃ©nÃ¨rent automatiquement du code lors de la crÃ©ation des classes.

**Fichier : `core/metaclasses.py`**

#### `NotificationMeta`
- GÃ©nÃ¨re automatiquement une mÃ©thode `validate_required_fields()` basÃ©e sur l'attribut `required_fields`
- Ajoute automatiquement une description si non fournie
- Enregistre la classe dans le `NotificationRegistry`
- DÃ©finit le type de notification automatiquement

#### `ChannelMeta`
- GÃ©nÃ¨re automatiquement le type de canal basÃ© sur le nom de la classe
- Ajoute une mÃ©thode `get_channel_info()` pour rÃ©cupÃ©rer les informations du canal

#### `TemplateMeta` - Nouveau!
- GÃ©nÃ¨re des templates de messages avec variables requises
- MÃ©thode `render_template()` pour substitution de variables
- Enregistrement automatique dans le registre global

#### `ConfigMeta` - Nouveau!
- GÃ¨re la configuration dynamique avec pattern Singleton
- MÃ©thodes `get_config()`, `set_config()`, `load_from_dict()`
- Validation automatique de la configuration

**Exemple d'utilisation :**
```python
class WeatherAlert(metaclass=NotificationMeta):
    required_fields = ['location', 'severity', 'effective_time']
    # La mÃ©thode validate_required_fields() est gÃ©nÃ©rÃ©e automatiquement

class EventTemplate(metaclass=TemplateMeta):
    required_variables = ['title', 'date', 'location']
    content = "Ã‰vÃ©nement: {{title}} le {{date}} Ã  {{location}}"
    # La mÃ©thode render_template() est gÃ©nÃ©rÃ©e automatiquement
```

## ğŸ”§ FonctionnalitÃ©s AvancÃ©es

### 1. SystÃ¨me d'Authentification et Autorisation
**Fichier : `core/auth.py`**

- Gestion des rÃ´les (Admin, User, API_User)
- SystÃ¨me de permissions granulaires
- Plusieurs mÃ©thodes d'authentification (JWT, API Key, Session)
- Hashage sÃ©curisÃ© des mots de passe (SHA256)

### 2. SystÃ¨me de Files d'Attente Asynchrones
**Fichier : `core/queue.py`**

- **AsyncQueue** - File d'attente asynchrone avec asyncio
- **ThreadPoolQueue** - File d'attente avec ThreadPoolExecutor
- Gestion des prioritÃ©s et des retries
- Surveillance et logging avancÃ©

### 3. API Modernes avec FastAPI
**Fichier : `api/main.py`**

- Routes complÃ¨tes pour utilisateurs, notifications et statistiques
- Authentification par token JWT, API Key et sessions
- Validation Pydantic pour toutes les entrÃ©es
- Documentation automatique OpenAPI/Swagger

## ğŸ—ï¸ Architecture du Projet

```
.
â”œâ”€â”€ app.py                          # Application Flask principale
â”œâ”€â”€ run_fastapi.py                  # Script de lancement FastAPI
â”œâ”€â”€ models.py                       # ModÃ¨les de base de donnÃ©es SQLAlchemy
â”œâ”€â”€ requirements.txt                # DÃ©pendances Python
â”œâ”€â”€ core/                           # Module des concepts POO avancÃ©s
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ decorators.py              # DÃ©corateurs de classes
â”‚   â”œâ”€â”€ descriptors.py             # Descripteurs de validation
â”‚   â”œâ”€â”€ metaclasses.py             # MÃ©taclasses pour gÃ©nÃ©ration de code
â”‚   â”œâ”€â”€ auth.py                    # SystÃ¨me d'authentification
â”‚   â”œâ”€â”€ queue.py                   # SystÃ¨me de files d'attente
â”‚   â””â”€â”€ notification_system.py     # SystÃ¨me de notification avec mixins
â”œâ”€â”€ api/                            # API FastAPI
â”‚   â””â”€â”€ main.py                    # Application FastAPI principale
â”œâ”€â”€ templates/                      # Templates HTML Jinja2
â”‚   â”œâ”€â”€ base.html                  # Template de base
â”‚   â”œâ”€â”€ index.html                 # Page d'envoi de notifications
â”‚   â”œâ”€â”€ dashboard.html             # Dashboard des notifications
â”‚   â””â”€â”€ admin.html                 # Administration des utilisateurs
â””â”€â”€ static/
    â””â”€â”€ css/
        â””â”€â”€ style.css              # Styles CSS personnalisÃ©s
```

## ğŸ”§ FonctionnalitÃ©s

### 1. SystÃ¨me de Notification Multi-Canal

- **Email** : Simulation d'envoi d'emails
- **SMS** : Simulation d'envoi de SMS
- **Push** : Simulation de notifications push

### 2. Gestion des PrioritÃ©s

Les prioritÃ©s sont dÃ©terminÃ©es automatiquement selon le type d'urgence :

- **CRITICAL** : SÃ©curitÃ©, SantÃ© â†’ Envoi sur tous les canaux
- **HIGH** : MÃ©tÃ©o â†’ Envoi selon prÃ©fÃ©rences utilisateur
- **MEDIUM** : Infrastructure â†’ Envoi selon prÃ©fÃ©rences utilisateur
- **LOW** : AcadÃ©mique â†’ Envoi selon prÃ©fÃ©rences utilisateur

### 3. Types d'Urgences

- ğŸŒ©ï¸ **MÃ©tÃ©o** : Alertes mÃ©tÃ©orologiques
- ğŸš¨ **SÃ©curitÃ©** : Alertes de sÃ©curitÃ© critiques
- ğŸ¥ **SantÃ©** : Alertes sanitaires
- ğŸ”§ **Infrastructure** : ProblÃ¨mes d'infrastructure
- ğŸ“š **AcadÃ©mique** : Notifications acadÃ©miques

### 4. Interface Web

- **Page d'envoi** : Formulaire pour envoyer des notifications
- **Dashboard** : Visualisation des notifications avec statistiques et filtres
- **Administration** : Gestion des utilisateurs avec validation automatique

### 5. API RESTful avec FastAPI

- Endpoints pour la gestion des utilisateurs
- Endpoints pour l'envoi et la gestion des notifications
- Endpoints pour les statistiques et mÃ©triques
- Documentation interactive Swagger UI

## ğŸš€ Installation et Utilisation

- body: Text
- emergency_type: String(50)
- priority: String(20) - ValidÃ© par PriorityDescriptor
- channels: String(200) - Canaux utilisÃ©s
- status: String(20)
- created_at: DateTime
```

### ModÃ¨le PerformanceMetric
```python
- id: Integer (clÃ© primaire)
- method_name: String(100)
- duration: Float - DurÃ©e en secondes
- timestamp: DateTime
```

## ğŸ¨ Design Patterns UtilisÃ©s

1. **Mixin Pattern** : SMSMixin, EmailMixin, PushNotificationMixin
2. **Decorator Pattern** : DÃ©corateurs de fonctions et de classes
3. **Registry Pattern** : NotificationRegistry pour enregistrer les notificateurs
4. **Circuit Breaker Pattern** : Gestion automatique des pannes
5. **Template Method Pattern** : Templates HTML avec Jinja2

## ğŸ” Validation des DonnÃ©es

La validation est effectuÃ©e Ã  plusieurs niveaux :

1. **Au niveau du formulaire** : Validation HTML5 cÃ´tÃ© client
2. **Au niveau des descripteurs** : Validation automatique lors de l'affectation
3. **Au niveau de la base de donnÃ©es** : Contraintes NOT NULL et UNIQUE

### Exemples de validation

**Email valide** : `etudiant@universite.edu` âœ…  
**Email invalide** : `etudiant.com` âŒ

**TÃ©lÃ©phone valide** : `+33612345678` âœ…  
**TÃ©lÃ©phone invalide** : `123456` âŒ

**PrioritÃ© valide** : `CRITICAL`, `HIGH`, `MEDIUM`, `LOW` âœ…  
**PrioritÃ© invalide** : `SUPER_HIGH` âŒ

## ğŸ§ª Tests et DÃ©monstration

### Tester l'envoi de notifications

1. Envoyez une notification de type "SÃ©curitÃ©" â†’ Observez l'envoi sur tous les canaux (CRITICAL)
2. Envoyez une notification de type "AcadÃ©mique" â†’ Observez l'envoi selon les prÃ©fÃ©rences (LOW)
3. Consultez le dashboard pour voir les statistiques mises Ã  jour

### Tester la validation

1. Essayez d'ajouter un utilisateur avec un email invalide â†’ Erreur de validation
2. Essayez d'ajouter un utilisateur avec un tÃ©lÃ©phone invalide â†’ Erreur de validation
3. Les descripteurs protÃ¨gent l'intÃ©gritÃ© des donnÃ©es

### Tester le Circuit Breaker

Le systÃ¨me simule alÃ©atoirement des Ã©checs d'envoi (10% de chance). Si trop d'Ã©checs se produisent, le circuit s'ouvre automatiquement pour protÃ©ger le systÃ¨me.

## ğŸ“š Justification des Choix Techniques

### Pourquoi les DÃ©corateurs de Classes ?

- **RÃ©utilisabilitÃ©** : Ajout de fonctionnalitÃ©s sans modifier les classes
- **SÃ©paration des prÃ©occupations** : Code mÃ©tier sÃ©parÃ© du code transversal
- **MaintenabilitÃ©** : Facile d'ajouter/retirer des fonctionnalitÃ©s

### Pourquoi les Descripteurs ?

- **Validation centralisÃ©e** : Une seule implÃ©mentation pour tous les usages
- **RÃ©utilisabilitÃ©** : MÃªmes descripteurs pour plusieurs classes
- **Encapsulation** : Logique de validation cachÃ©e dans le descripteur

### Pourquoi les MÃ©taclasses ?

- **GÃ©nÃ©ration de code** : CrÃ©ation automatique de mÃ©thodes rÃ©pÃ©titives
- **Convention over Configuration** : Comportement automatique basÃ© sur les conventions
- **DRY (Don't Repeat Yourself)** : Ã‰vite la duplication de code

### Pourquoi Flask ?

- **SimplicitÃ©** : Courbe d'apprentissage douce
- **FlexibilitÃ©** : ContrÃ´le total sur l'architecture
- **ExtensibilitÃ©** : Facile d'ajouter de nouvelles fonctionnalitÃ©s
- **AdaptÃ© pour prototypage** : IdÃ©al pour un projet Ã©tudiant

## ğŸ”„ ExtensibilitÃ©

Le systÃ¨me est conÃ§u pour Ãªtre facilement extensible :

1. **Ajouter un nouveau canal** :
   ```python
   class SlackMixin:
       def send_slack(self, message, channel):
           # ImplÃ©mentation
   ```

2. **Ajouter un nouveau type d'urgence** :
   ```python
   class EmergencyType(Enum):
       NEW_TYPE = "nouveau_type"
   ```

3. **Ajouter un nouveau descripteur** :
   ```python
   class URLDescriptor:
       def __set__(self, instance, value):
           # Validation URL
   ```

## ğŸ“ Valeur PÃ©dagogique

Ce projet dÃ©montre :

- L'utilisation pratique de concepts POO avancÃ©s
- L'intÃ©gration de ces concepts dans une application rÃ©elle
- Les avantages de la programmation orientÃ©e objet pour la maintenabilitÃ©
- Les patterns de conception modernes en Python

## ğŸ“ Notes Importantes

- Les envois de notifications sont **simulÃ©s** (pas d'intÃ©gration rÃ©elle SMS/Email)
- La base de donnÃ©es est PostgreSQL en dÃ©veloppement
- L'application utilise Flask en mode debug (Ã  ne pas utiliser en production)
- Les descripteurs sont utilisÃ©s via des fonctions de validation compatibles avec SQLAlchemy

## ğŸ¤ Auteur

Projet Ã©tudiant - SystÃ¨me de Notification AcadÃ©mique  
Framework : Flask + PostgreSQL  
Concepts : POO AvancÃ©e (DÃ©corateurs, Descripteurs, MÃ©taclasses)

---

**Note** : Ce projet est conÃ§u Ã  des fins pÃ©dagogiques pour dÃ©montrer l'utilisation de concepts POO avancÃ©s en Python dans un contexte d'application web rÃ©elle.
